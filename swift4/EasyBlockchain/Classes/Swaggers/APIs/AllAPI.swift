//
// AllAPI.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire



open class AllAPI {
    /**
     Determine chain id exists
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func chainIdExists(context: String, chainId: String, completion: @escaping ((_ data: IdResponse?,_ error: Error?) -> Void)) {
        chainIdExistsWithRequestBuilder(context: context, chainId: chainId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Determine chain id exists
     - GET /{context}/chains/id/{chainId}
     - Determine whether the Id of a chain exists in the blockchain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "exists" : "True",
  "Id" : "aeiou"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 

     - returns: RequestBuilder<IdResponse> 
     */
    open class func chainIdExistsWithRequestBuilder(context: String, chainId: String) -> RequestBuilder<IdResponse> {
        var path = "/{context}/chains/id/{chainId}"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<IdResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Create a new backend
     
     - parameter backend: (body) backend 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func createBackend(backend: Backend, completion: @escaping ((_ data: Backend?,_ error: Error?) -> Void)) {
        createBackendWithRequestBuilder(backend: backend).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Create a new backend
     - POST /backends
     - Create a new backend. A Backend is the link to one blockchain implementation and it' s nodes. Unless you create your own private blockchain network, you should not have to create a new backend. Just use one of the public backends available.
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "rpcProviders" : [ {
    "ownerType" : "PROVIDER",
    "metaData" : {
      "key" : "aeiou"
    },
    "password" : "aeiou",
    "access" : {
      "modes" : [ "NONE" ],
      "blackList" : [ "aeiou" ],
      "whiteList" : [ "aeiou" ]
    },
    "ledgerName" : "aeiou",
    "resourceFiles" : {
      "key" : "aeiou"
    },
    "walletInfo" : "aeiou",
    "host" : "aeiou",
    "id" : "aeiou",
    "type" : "API",
    "username" : "aeiou"
  } ],
  "apiVersion" : 0,
  "name" : "aeiou",
  "start" : "2000-01-23T04:56:07.000+00:00",
  "end" : "2000-01-23T04:56:07.000+00:00",
  "dataStructure" : "FACTOM",
  "id" : "aeiou",
  "externalAccess" : ""
}}]
     
     - parameter backend: (body) backend 

     - returns: RequestBuilder<Backend> 
     */
    open class func createBackendWithRequestBuilder(backend: Backend) -> RequestBuilder<Backend> {
        let path = "/backends"
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: backend)

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<Backend>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a new chain
     
     - parameter context: (path) context 
     - parameter chain: (body) Create a chain using the first entry supplied. The entry needs at least a (combination of) globaly unique external Id in the complete Blockchain network! 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func createChain(context: String, chain: Chain, completion: @escaping ((_ data: CommittedChainResponse?,_ error: Error?) -> Void)) {
        createChainWithRequestBuilder(context: context, chain: chain).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Create a new chain
     - POST /{context}/chains
     - Create a new chain. Create a new chain. You can regard a chain as a blockchain within a blockchain, All entries in a chain are linked and relies on data from previous entries in the chain.
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "chain" : {
    "chain" : {
      "firstEntry" : {
        "entryData" : {
          "externalIds" : [ {
            "value" : "aeiou"
          } ],
          "content" : "aeiou"
        }
      }
    },
    "id" : "aeiou"
  },
  "commitTime" : "2000-01-23T04:56:07.000+00:00",
  "creationRequestTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chain: (body) Create a chain using the first entry supplied. The entry needs at least a (combination of) globaly unique external Id in the complete Blockchain network! 

     - returns: RequestBuilder<CommittedChainResponse> 
     */
    open class func createChainWithRequestBuilder(context: String, chain: Chain) -> RequestBuilder<CommittedChainResponse> {
        var path = "/{context}/chains"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: chain)

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<CommittedChainResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create context
     
     - parameter context: (body) context 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func createContext(context: Context, completion: @escaping ((_ data: Context?,_ error: Error?) -> Void)) {
        createContextWithRequestBuilder(context: context).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Create context
     - POST /contexts
     - Create a new context
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "access" : {
    "modes" : [ "NONE" ],
    "blackList" : [ "aeiou" ],
    "whiteList" : [ "aeiou" ]
  },
  "backendIds" : [ "aeiou" ],
  "name" : "aeiou",
  "id" : "aeiou"
}}]
     
     - parameter context: (body) context 

     - returns: RequestBuilder<Context> 
     */
    open class func createContextWithRequestBuilder(context: Context) -> RequestBuilder<Context> {
        let path = "/contexts"
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: context)

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<Context>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Create a new entry in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Create a new entry for the specified chain 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func createEntry(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: CommittedEntryResponse?,_ error: Error?) -> Void)) {
        createEntryWithRequestBuilder(context: context, chainId: chainId, entry: entry, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Create a new entry in the provided chain
     - POST /{context}/chains/{chainId}/entries
     - Create a new entry in the provided chain. The entry will be linked to the previous entry. If the entry already exists, the API will add an anchor time, since the entry Id would be the same as the previously registered entry
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "entry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "commitTime" : "2000-01-23T04:56:07.000+00:00",
  "creationRequestTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Create a new entry for the specified chain 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<CommittedEntryResponse> 
     */
    open class func createEntryWithRequestBuilder(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil) -> RequestBuilder<CommittedEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: entry)

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<CommittedEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Delete a backend
     
     - parameter backendId: (path) backendId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func deleteBackend(backendId: String, completion: @escaping ((_ data: Backend?,_ error: Error?) -> Void)) {
        deleteBackendWithRequestBuilder(backendId: backendId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Delete a backend
     - DELETE /backends/{backendId}
     - Delete backend by id (not by name)
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{output=none}]
     
     - parameter backendId: (path) backendId 

     - returns: RequestBuilder<Backend> 
     */
    open class func deleteBackendWithRequestBuilder(backendId: String) -> RequestBuilder<Backend> {
        var path = "/backends/{backendId}"
        path = path.replacingOccurrences(of: "{backendId}", with: "\(backendId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<Backend>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Delete context
     
     - parameter context: (path) context 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func deleteContext(context: String, completion: @escaping ((_ data: Context?,_ error: Error?) -> Void)) {
        deleteContextWithRequestBuilder(context: context).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Delete context
     - DELETE /contexts/{context}
     - Delete an existing context
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "access" : {
    "modes" : [ "NONE" ],
    "blackList" : [ "aeiou" ],
    "whiteList" : [ "aeiou" ]
  },
  "backendIds" : [ "aeiou" ],
  "name" : "aeiou",
  "id" : "aeiou"
}}]
     
     - parameter context: (path) context 

     - returns: RequestBuilder<Context> 
     */
    open class func deleteContextWithRequestBuilder(context: String) -> RequestBuilder<Context> {
        var path = "/contexts/{context}"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<Context>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Predetermine id of chain
     
     - parameter context: (path) context 
     - parameter chain: (body) Determine a chain hash. The entry needs at least a (combination of) globally unique external Id in the complete Blockchain network! 
     - parameter checkExistence: (query) Check whether the id exists (optional, default to false)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func determineChainId(context: String, chain: Chain, checkExistence: Bool? = nil, completion: @escaping ((_ data: IdResponse?,_ error: Error?) -> Void)) {
        determineChainIdWithRequestBuilder(context: context, chain: chain, checkExistence: checkExistence).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Predetermine id of chain
     - POST /{context}/chains/id
     - Pre determine the Id of a chain without anchoring it in the blockchain. You determine the Id that the chain would receive once it would have been anchored
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "exists" : "True",
  "Id" : "aeiou"
}}]
     
     - parameter context: (path) context 
     - parameter chain: (body) Determine a chain hash. The entry needs at least a (combination of) globally unique external Id in the complete Blockchain network! 
     - parameter checkExistence: (query) Check whether the id exists (optional, default to false)

     - returns: RequestBuilder<IdResponse> 
     */
    open class func determineChainIdWithRequestBuilder(context: String, chain: Chain, checkExistence: Bool? = nil) -> RequestBuilder<IdResponse> {
        var path = "/{context}/chains/id"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: chain)

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "checkExistence": checkExistence
        ])
        

        let requestBuilder: RequestBuilder<IdResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Predetermine id of an entry
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) The entry to determine the hash for on the specified chain 
     - parameter checkExistence: (query) Check whether the id exists (optional, default to false)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func determineEntryId(context: String, chainId: String, entry: Entry, checkExistence: Bool? = nil, completion: @escaping ((_ data: IdResponse?,_ error: Error?) -> Void)) {
        determineEntryIdWithRequestBuilder(context: context, chainId: chainId, entry: entry, checkExistence: checkExistence).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Predetermine id of an entry
     - POST /{context}/chains/id/{chainId}/entries
     - Pre determine the Id of an entry request without anchoring the entry
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "exists" : "True",
  "Id" : "aeiou"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) The entry to determine the hash for on the specified chain 
     - parameter checkExistence: (query) Check whether the id exists (optional, default to false)

     - returns: RequestBuilder<IdResponse> 
     */
    open class func determineEntryIdWithRequestBuilder(context: String, chainId: String, entry: Entry, checkExistence: Bool? = nil) -> RequestBuilder<IdResponse> {
        var path = "/{context}/chains/id/{chainId}/entries"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: entry)

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "checkExistence": checkExistence
        ])
        

        let requestBuilder: RequestBuilder<IdResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Get an existing entry in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func entryById(context: String, chainId: String, entryId: String, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        entryByIdWithRequestBuilder(context: context, chainId: chainId, entryId: entryId, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get an existing entry in the provided chain
     - GET /{context}/chains/{chainId}/entries/{entryId}
     - Get an existing entry in the provided chain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func entryByIdWithRequestBuilder(context: String, chainId: String, entryId: String, currentAnchorTime: Date? = nil) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/{entryId}"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{entryId}", with: "\(entryId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get an existing entry in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Retrieve the entry 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func entryByRequest(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        entryByRequestWithRequestBuilder(context: context, chainId: chainId, entry: entry, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get an existing entry in the provided chain
     - POST /{context}/chains/{chainId}/entries/entry
     - Get an existing entry in the provided chain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Retrieve the entry 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func entryByRequestWithRequestBuilder(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/entry"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: entry)

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Determine entry id exists
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func entryIdExists(context: String, chainId: String, entryId: String, completion: @escaping ((_ data: IdResponse?,_ error: Error?) -> Void)) {
        entryIdExistsWithRequestBuilder(context: context, chainId: chainId, entryId: entryId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Determine entry id exists
     - GET /{context}/chains/id/{chainId}/entries/{entryId}
     - Determine whether the Id of an entry exists in the blockchain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "exists" : "True",
  "Id" : "aeiou"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 

     - returns: RequestBuilder<IdResponse> 
     */
    open class func entryIdExistsWithRequestBuilder(context: String, chainId: String, entryId: String) -> RequestBuilder<IdResponse> {
        var path = "/{context}/chains/id/{chainId}/entries/{entryId}"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{entryId}", with: "\(entryId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<IdResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Find backends
     
     - parameter backendId: (path) backendId 
     - parameter includePublic: (query) includePublic (optional, default to false)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func findBackends(backendId: String, includePublic: Bool? = nil, completion: @escaping ((_ data: [Backend]?,_ error: Error?) -> Void)) {
        findBackendsWithRequestBuilder(backendId: backendId, includePublic: includePublic).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Find backends
     - GET /backends/{backendId}/find
     - Find existing backend(s) by id (single result) and/or name (multiple results). Optionally including public backends of others. Please note that we never return sensitive information like password or rpc hosts. Even not for backend owners themselves
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example=[ {
  "rpcProviders" : [ {
    "ownerType" : "PROVIDER",
    "metaData" : {
      "key" : "aeiou"
    },
    "password" : "aeiou",
    "access" : {
      "modes" : [ "NONE" ],
      "blackList" : [ "aeiou" ],
      "whiteList" : [ "aeiou" ]
    },
    "ledgerName" : "aeiou",
    "resourceFiles" : {
      "key" : "aeiou"
    },
    "walletInfo" : "aeiou",
    "host" : "aeiou",
    "id" : "aeiou",
    "type" : "API",
    "username" : "aeiou"
  } ],
  "apiVersion" : 0,
  "name" : "aeiou",
  "start" : "2000-01-23T04:56:07.000+00:00",
  "end" : "2000-01-23T04:56:07.000+00:00",
  "dataStructure" : "FACTOM",
  "id" : "aeiou",
  "externalAccess" : ""
} ]}]
     
     - parameter backendId: (path) backendId 
     - parameter includePublic: (query) includePublic (optional, default to false)

     - returns: RequestBuilder<[Backend]> 
     */
    open class func findBackendsWithRequestBuilder(backendId: String, includePublic: Bool? = nil) -> RequestBuilder<[Backend]> {
        var path = "/backends/{backendId}/find"
        path = path.replacingOccurrences(of: "{backendId}", with: "\(backendId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "includePublic": includePublic
        ])
        

        let requestBuilder: RequestBuilder<[Backend]>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get the first entry in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func firstEntry(context: String, chainId: String, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        firstEntryWithRequestBuilder(context: context, chainId: chainId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get the first entry in the provided chain
     - GET /{context}/chains/{chainId}/entries/first
     - Get the first entry in the provided chain. This is the oldest entry also called the chain tail.  Please note that the achorTimes will only contain the first anchor time. Call getEntry to retrieve all times
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func firstEntryWithRequestBuilder(context: String, chainId: String) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/first"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get backend by id
     
     - parameter backendId: (path) backendId 
     - parameter includePublic: (query) includePublic (optional, default to false)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func getBackend(backendId: String, includePublic: Bool? = nil, completion: @escaping ((_ data: Backend?,_ error: Error?) -> Void)) {
        getBackendWithRequestBuilder(backendId: backendId, includePublic: includePublic).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get backend by id
     - GET /backends/{backendId}
     - Get existing backend by id (not by name). Optionally including public backend of others. Please note that we never return sensitive information like password or rpc hosts. Even not for backend owners themselves
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "rpcProviders" : [ {
    "ownerType" : "PROVIDER",
    "metaData" : {
      "key" : "aeiou"
    },
    "password" : "aeiou",
    "access" : {
      "modes" : [ "NONE" ],
      "blackList" : [ "aeiou" ],
      "whiteList" : [ "aeiou" ]
    },
    "ledgerName" : "aeiou",
    "resourceFiles" : {
      "key" : "aeiou"
    },
    "walletInfo" : "aeiou",
    "host" : "aeiou",
    "id" : "aeiou",
    "type" : "API",
    "username" : "aeiou"
  } ],
  "apiVersion" : 0,
  "name" : "aeiou",
  "start" : "2000-01-23T04:56:07.000+00:00",
  "end" : "2000-01-23T04:56:07.000+00:00",
  "dataStructure" : "FACTOM",
  "id" : "aeiou",
  "externalAccess" : ""
}}]
     
     - parameter backendId: (path) backendId 
     - parameter includePublic: (query) includePublic (optional, default to false)

     - returns: RequestBuilder<Backend> 
     */
    open class func getBackendWithRequestBuilder(backendId: String, includePublic: Bool? = nil) -> RequestBuilder<Backend> {
        var path = "/backends/{backendId}"
        path = path.replacingOccurrences(of: "{backendId}", with: "\(backendId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "includePublic": includePublic
        ])
        

        let requestBuilder: RequestBuilder<Backend>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get context
     
     - parameter context: (path) context 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func getContext(context: String, completion: @escaping ((_ data: Context?,_ error: Error?) -> Void)) {
        getContextWithRequestBuilder(context: context).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get context
     - GET /contexts/{context}
     - Get an existing context
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "access" : {
    "modes" : [ "NONE" ],
    "blackList" : [ "aeiou" ],
    "whiteList" : [ "aeiou" ]
  },
  "backendIds" : [ "aeiou" ],
  "name" : "aeiou",
  "id" : "aeiou"
}}]
     
     - parameter context: (path) context 

     - returns: RequestBuilder<Context> 
     */
    open class func getContextWithRequestBuilder(context: String) -> RequestBuilder<Context> {
        var path = "/contexts/{context}"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<Context>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get the last entry in the provided chain.
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func lastEntry(context: String, chainId: String, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        lastEntryWithRequestBuilder(context: context, chainId: chainId).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get the last entry in the provided chain.
     - GET /{context}/chains/{chainId}/entries/last
     - Get the last entry in the provided chain. This is the most recent entry also called the chain head. Please note that the achorTimes will only contain the latest anchor time. Call getEntry to retrieve all times
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func lastEntryWithRequestBuilder(context: String, chainId: String) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/last"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)


        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     List backends
     
     - parameter includePublic: (query) includePublic (optional, default to false)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func listBackends(includePublic: Bool? = nil, completion: @escaping ((_ data: [Backend]?,_ error: Error?) -> Void)) {
        listBackendsWithRequestBuilder(includePublic: includePublic).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     List backends
     - GET /backends
     - List existing backends. Optionally including public backends of others.  Please note that we never return sensitive information like password or rpc hosts. Even not for backend owners themselves
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example=[ {
  "rpcProviders" : [ {
    "ownerType" : "PROVIDER",
    "metaData" : {
      "key" : "aeiou"
    },
    "password" : "aeiou",
    "access" : {
      "modes" : [ "NONE" ],
      "blackList" : [ "aeiou" ],
      "whiteList" : [ "aeiou" ]
    },
    "ledgerName" : "aeiou",
    "resourceFiles" : {
      "key" : "aeiou"
    },
    "walletInfo" : "aeiou",
    "host" : "aeiou",
    "id" : "aeiou",
    "type" : "API",
    "username" : "aeiou"
  } ],
  "apiVersion" : 0,
  "name" : "aeiou",
  "start" : "2000-01-23T04:56:07.000+00:00",
  "end" : "2000-01-23T04:56:07.000+00:00",
  "dataStructure" : "FACTOM",
  "id" : "aeiou",
  "externalAccess" : ""
} ]}]
     
     - parameter includePublic: (query) includePublic (optional, default to false)

     - returns: RequestBuilder<[Backend]> 
     */
    open class func listBackendsWithRequestBuilder(includePublic: Bool? = nil) -> RequestBuilder<[Backend]> {
        let path = "/backends"
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "includePublic": includePublic
        ])
        

        let requestBuilder: RequestBuilder<[Backend]>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get the entry after the supplied entry Id (the next) in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func nextEntryById(context: String, chainId: String, entryId: String, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        nextEntryByIdWithRequestBuilder(context: context, chainId: chainId, entryId: entryId, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get the entry after the supplied entry Id (the next) in the provided chain
     - GET /{context}/chains/{chainId}/entries/{entryId}/next
     - Get the entry after the supplied entry Id (the next) in the provided chain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func nextEntryByIdWithRequestBuilder(context: String, chainId: String, entryId: String, currentAnchorTime: Date? = nil) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/{entryId}/next"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{entryId}", with: "\(entryId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get the entry after the supplied entry Id (the next) in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Retrieve the entry 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func nextEntryByRequest(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        nextEntryByRequestWithRequestBuilder(context: context, chainId: chainId, entry: entry, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get the entry after the supplied entry Id (the next) in the provided chain
     - POST /{context}/chains/{chainId}/entries/entry/next
     - Get the entry after the supplied entry Id (the next) in the provided chain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Retrieve the entry 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func nextEntryByRequestWithRequestBuilder(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/entry/next"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: entry)

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Get the entry before the supplied entry Id (the previous) in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func previousEntryById(context: String, chainId: String, entryId: String, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        previousEntryByIdWithRequestBuilder(context: context, chainId: chainId, entryId: entryId, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get the entry before the supplied entry Id (the previous) in the provided chain
     - GET /{context}/chains/{chainId}/entries/{entryId}/previous
     - Get the entry before the supplied entry Id (the previous) in the provided chain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entryId: (path) entryId 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func previousEntryByIdWithRequestBuilder(context: String, chainId: String, entryId: String, currentAnchorTime: Date? = nil) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/{entryId}/previous"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{entryId}", with: "\(entryId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters: [String:Any]? = nil

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get the entry before the supplied entry Id (the previous) in the provided chain
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Retrieve the entry 
     - parameter currentAnchorTime: (query)  (optional)
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func previousEntryByRequest(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil, completion: @escaping ((_ data: AnchoredEntryResponse?,_ error: Error?) -> Void)) {
        previousEntryByRequestWithRequestBuilder(context: context, chainId: chainId, entry: entry, currentAnchorTime: currentAnchorTime).execute { (response, error) -> Void in
            completion(response?.body, error);
        }
    }


    /**
     Get the entry before the supplied entry Id (the previous) in the provided chain
     - POST /{context}/chains/{chainId}/entries/entry/previous
     - Get the entry before the supplied entry Id (the previous) in the provided chain
     - OAuth:
       - type: oauth2
       - name: oauth2schema
     - examples: [{contentType=application/json;charset=UTF-8, example={
  "anchoredEntry" : {
    "entry" : {
      "entryData" : {
        "externalIds" : [ {
          "value" : "aeiou"
        } ],
        "content" : "aeiou"
      }
    },
    "chainId" : "aeiou",
    "rawBackendStructure" : "aeiou",
    "entryId" : "aeiou"
  },
  "anchorTimes" : [ "2000-01-23T04:56:07.000+00:00" ],
  "currentAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "anchorState" : "REQUESTED",
  "lastAnchorTime" : "2000-01-23T04:56:07.000+00:00",
  "firstAnchorTime" : "2000-01-23T04:56:07.000+00:00"
}}]
     
     - parameter context: (path) context 
     - parameter chainId: (path) chainId 
     - parameter entry: (body) Retrieve the entry 
     - parameter currentAnchorTime: (query)  (optional)

     - returns: RequestBuilder<AnchoredEntryResponse> 
     */
    open class func previousEntryByRequestWithRequestBuilder(context: String, chainId: String, entry: Entry, currentAnchorTime: Date? = nil) -> RequestBuilder<AnchoredEntryResponse> {
        var path = "/{context}/chains/{chainId}/entries/entry/previous"
        path = path.replacingOccurrences(of: "{context}", with: "\(context)", options: .literal, range: nil)
        path = path.replacingOccurrences(of: "{chainId}", with: "\(chainId)", options: .literal, range: nil)
        let URLString = EasyBlockchainAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: entry)

        let url = NSURLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems(values:[
            "currentAnchorTime": currentAnchorTime?.encodeToJSON()
        ])
        

        let requestBuilder: RequestBuilder<AnchoredEntryResponse>.Type = EasyBlockchainAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

}
