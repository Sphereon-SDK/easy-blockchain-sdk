<?php
/**
 * Easy Blockchain API
 *
 * The Easy Blockchain API is an easy to use API to store related entries within chains. Currently it stores entries using a Factom, Ethereum or Multichain blockchain.   For full API documentation please visit: https://docs.sphereon.com/api/easy-blockchain/0.10/html   Interactive testing: A web based test console is available in the Sphereon API store at: https://store.sphereon.com
 *
 * OpenAPI spec version: 0.10
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */
namespace Sphereon\SDK\Blockchain\Easy;

use \Sphereon\SDK\Blockchain\Easy\Configuration;
use \Sphereon\SDK\Blockchain\Easy\ApiClient;
use \Sphereon\SDK\Blockchain\Easy\ApiException;
use \Sphereon\SDK\Blockchain\Easy\ObjectSerializer;
use \Sphereon\SDK\Blockchain\Easy\Api\AllApi;
use \Sphereon\SDK\Blockchain\Easy\Model\ExternalId;
use \Sphereon\SDK\Blockchain\Easy\Model\EntryData;
use \Sphereon\SDK\Blockchain\Easy\Model\Chain;
use \Sphereon\SDK\Blockchain\Easy\Model\Entry;
use \Sphereon\SDK\Blockchain\Easy\Model\IdResponse;
use \Sphereon\SDK\Blockchain\Easy\Model\CommittedChainResponse;
use \Sphereon\SDK\Blockchain\Easy\Model\CommittedEntryResponse;
use \Sphereon\SDK\Blockchain\Easy\Model\AnchoredEntryResponse;

/**
 * EasyBlockchainApiTest Class Doc Comment
 *
 * @category Class
 * @package  Sphereon\SDK\Blockchain\Easy
 * @author   Sphereon Development team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EasyBlockchainApiTest extends \PHPUnit_Framework_TestCase
{
	private $api_instance;
	
	private $context = "multichain";
	private $test_chain_id = "502b99271ff6a3f8509ba2764e1e1c1482ad800140c17b25e165837ab5320501";
	
    /**
     * Setup before running any test cases
     */
    public static function setUpBeforeClass()
    {
    }

    /**
     * Setup before running each test case
     */
    public function setUp()
    {
		Configuration::getDefaultConfiguration()->setAccessToken('YOUR_API_TOKEN');
		$this->api_instance = new AllApi();
    }

    /**
     * Clean up after running each test case
     */
    public function tearDown()
    {
    }

    /**
     * Clean up after running all test cases
     */
    public static function tearDownAfterClass()
    {
    }
	
    /**
     * Test case for createChain
     *
     * Create a new chain.
     *
     */
    public function testCreateChain()
    {
		$chain = $this->createChain("Test Content", array("first external id", "second external id"));

		$result = $this->api_instance->createChain($this->context, $chain);
		
		$this->assertInstanceOf(CommittedChainResponse::class, $result);
		$this->assertNotNull($result);
		$this->assertNotNull($result->getChain());
		$this->assertNotNull($result->getCommitTime());
		$this->assertNotNull($result->getCreationRequestTime());
    }
	
    /**
     * Test case for chainIdExists
     *
     * Determine chain id exists.
	 *
     * @depends testCreateChain
	 *
     */
    public function testChainIdExists()
    {
		$result = $this->api_instance->chainIdExists($this->context, $this->test_chain_id);
		$this->assertInstanceOf(IdResponse::class, $result);
    }

    /**
     * Test case for entryByRequest
     *
     * Get an existing entry in the provided chain.
	 *
     * @depends testCreateChain
     *
     */
    public function testEntryByRequest()
    {
		$entry = $this->createEntry("Test Content", array("first external id", "second external id"));
		
	    $result = $this->api_instance->entryByRequest($this->context, $this->test_chain_id, $entry, null);
		
		$this->assertInstanceOf(AnchoredEntryResponse::class, $result);
		$this->assertNotNull($result);
		$this->assertNotNull($result->getAnchoredEntry());
		$this->assertTrue($result->getAnchorTimes() >= 3);
		$this->assertEquals('ANCHORED', $result->getAnchorState());
    }

    /**
     * Test case for createEntry
     *
     * Create a new entry in the provided chain.
     *
     * @depends testEntryByRequest
     *
     */
    public function testCreateEntry()
    {
		$extId = sprintf("first external id %s", microtime());
		$entry = $this->createEntry("Test Content", array($extId));
		
		$result = $this->api_instance->createEntry($this->context, $this->test_chain_id, $entry, null);
		
		$this->assertInstanceOf(CommittedEntryResponse::class, $result);
		$this->assertNotNull($result);
		$this->assertNotNull($result->getEntry());
		$this->assertNotNull($result->getCreationRequestTime());
		
		sleep (10); // Should be enough for multichain
		
		$result = $this->api_instance->entryByRequest($this->context, $this->test_chain_id, $entry, null);
		
		$this->assertInstanceOf(AnchoredEntryResponse::class, $result);
		$this->assertNotNull($result);
		$this->assertNotNull($result->getAnchoredEntry());
		$this->assertTrue($result->getAnchorTimes() >= 0);
		$this->assertTrue($result->getAnchorState() == 'ANCHORED' || $result->getAnchorState() == 'COMMITTED');
    }
	
    /**
     * Test case for determineChainId
     *
     * Predetermine id of chain.
     *
     */
    public function testDetermineChainId()
    {
		$check_existence = false;
		$chain = $this->createChain("Test Content", array("Test External ID1","Test External ID2"));
		
		$result = $this->api_instance->determineChainId($this->context, $chain, $check_existence);
		
		$this->assertInstanceOf(IdResponse::class, $result);
		$this->assertNotNull($result->getId());
    }

    /**
     * Test case for determineEntryId
     *
     * Predetermine id of an entry.
     *
     */
    public function testDetermineEntryId()
    {
		$check_existence = false;
		$entry = $this->createEntry("Test Content", array("Test External ID1","Test External ID2"));
		
		$result = $this->api_instance->determineEntryId($this->context, $this->test_chain_id, $entry, $check_existence);
		
		$this->assertInstanceOf(IdResponse::class, $result);
		$this->assertNotNull($result->getId());
    }
	
	function createChain($content, $external_id_values) 
	{
		$entry = $this->createEntry($content, $external_id_values);

		$chain = new Chain();
		$chain->setFirstEntry($entry);
		
		return $chain;
	}
	
	function createEntry($content, $external_id_values)
	{
		$external_ids = array_map(array($this, 'createExternalId'), $external_id_values);
		$entry_data = new EntryData();
		$entry_data->setContent(base64_encode($content));
		$entry_data->setExternalIds($external_ids);
		
		$entry = new Entry();
		$entry->setEntryData($entry_data);
		return $entry;
	}
	
	function createExternalId($external_id_value)
	{
		$external_id = new ExternalId();
		$external_id->setValue(base64_encode($external_id_value)); 
		return $external_id;
	}
}
