package com.sphereon.sdk.blockchain.easy.api;

import com.sphereon.libs.authentication.api.AuthenticationApi;
import com.sphereon.libs.authentication.api.TokenRequest;
import com.sphereon.libs.authentication.api.config.ApiConfiguration;
import com.sphereon.libs.authentication.api.config.PersistenceMode;
import com.sphereon.libs.authentication.api.config.PersistenceType;
import com.sphereon.libs.blockchain.commons.Digest;
import com.sphereon.libs.blockchain.commons.Digest.Algorithm;
import com.sphereon.sdk.blockchain.easy.model.CommittedEntryResponse;
import com.sphereon.sdk.blockchain.easy.model.Entry;
import com.sphereon.sdk.blockchain.easy.model.EntryData;
import com.sphereon.sdk.blockchain.easy.model.ExternalId;
import com.sphereon.sdk.blockchain.proof.api.ConfigurationApi;
import com.sphereon.sdk.blockchain.proof.api.RegistrationApi;
import com.sphereon.sdk.blockchain.proof.api.VerificationApi;
import com.sphereon.sdk.blockchain.proof.handler.ApiException;
import com.sphereon.sdk.blockchain.proof.model.ChainSettings;
import com.sphereon.sdk.blockchain.proof.model.ChainSettings.ContentRegistrationChainTypesEnum;
import com.sphereon.sdk.blockchain.proof.model.ChainSettings.HashAlgorithmEnum;
import com.sphereon.sdk.blockchain.proof.model.ChainSettings.VersionEnum;
import com.sphereon.sdk.blockchain.proof.model.ConfigurationResponse;
import com.sphereon.sdk.blockchain.proof.model.ContentRequest;
import com.sphereon.sdk.blockchain.proof.model.ContentRequest.HashProviderEnum;
import com.sphereon.sdk.blockchain.proof.model.CreateConfigurationRequest;
import com.sphereon.sdk.blockchain.proof.model.CreateConfigurationRequest.AccessModeEnum;
import com.sphereon.sdk.blockchain.proof.model.RegisterContentResponse;
import com.sphereon.sdk.blockchain.proof.model.SignatureSettings;
import com.sphereon.sdk.blockchain.proof.model.SignatureSettings.SignatureTypeEnum;
import com.sphereon.sdk.blockchain.proof.model.VerifyContentResponse;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Base64;
import java.util.UUID;
import org.junit.Assert;
import org.junit.Test;

/**
 * This example combines usage of the blockchain proof API to register content/files to get a unique chain id per hash Once the chain has been
 * created, the response contains the chain id. We use that chain id and the easy blockchain API to create additional entries with metadata in the
 * chain for that hash. In this example we are creating 2 actions for different users, to denote they have made an approval on the document belonging
 * to this hash.
 * <p>
 * This example is rather simple. Given anybody could put hashes on the blockchain, we suggest to sign the hash using an asymmetrical key, or by using
 * our crypto-keys API. This ensures you can always check that the hash really has been generated by your application
 */
public class EasyBlockchainAndProofExample {

    public static final long TOKEN_VALIDITY_SECONDS = 5400;
    // This context for the Easy Blockchain is available to everyone and uses the Factom Blockchain
    public static final String FACTOM_PUBLIC_CONTEXT = "factom";
    // This Blockchain Proof configuration name needs to be availble. Replace with your config name. We generate one on the fly for this example
    public static final String BLOCKCHAIN_PROOF_CONFIG = "example";

    // The easy blockchain and blockchain proof SDK clients
    private final AllApi easyBlockchainApi = new AllApi();
    private final RegistrationApi blockchainProofRegApi = new RegistrationApi();
    private final VerificationApi blockchainProofVerApi = new VerificationApi();
    private final ConfigurationApi blockchainProofConfApi = new ConfigurationApi();

    // These are our tags/external ids when creating entries on the blockchain
    public static final String APPLICATION_NAME = "EXAMPLE-APP";
    public static final String ACTION = "APPROVE";
    public static final String V_1 = "v1";

    // Example data that we use as input for a hash
    public static final String EMAIL1 = "example1@example.com";
    public static final String EMAIL2 = "example2@example.com";
    public static final String USER_ID1 = UUID.randomUUID().toString();
    public static final String USER_ID2 = UUID.randomUUID().toString();

    /**
     * This example uses blockchain proof to register a new chain, then uses the easy blockchain to register entries
     * <p>
     * For this example a so called chain per hash is being used. Meaning that a different hash results in a different chain for the entries.
     *
     * @throws ApiException
     */
    @Test
    public void example() {
        try {
            configureApis();
            // In your application the blockchain proof config only needs to be created once, which could even be done outside of your code
            createBlockchainProofConfig();

            // Create a SHA-256 hash from random content using the easy blockchain lib. Could also be file contents
            final byte[] hash = Digest.getInstance()
              .getHash(Algorithm.SHA_256, String.format("Unique Example input: %d", System.currentTimeMillis()));

            // We want to register a new per hash chain with some content. We have chosen to hash the submitted value ourselves
            final ContentRequest proofRequest = new ContentRequest().hashProvider(HashProviderEnum.CLIENT).content(hash);

            System.out.println("Registering new chain...");
            // Register the chain using the blockchain proof API
            final RegisterContentResponse registerResponse;

            registerResponse = blockchainProofRegApi
              .registerUsingContent(BLOCKCHAIN_PROOF_CONFIG, proofRequest, "example-id", null, null, null);

            // Retrieve the per hash chain id from the response. Typically makes sense to store this in the DB for later usage
            final String chainId = registerResponse.getPerHashProofChain().getChainId();
            System.out.println(String.format("Chain ID of newly created chain: %s", chainId));

            // Alternatively we can always determine the chainId even if we have not registered it before or forgot the value. It will also return whether the chain exists
            final VerifyContentResponse verifyResponse = blockchainProofVerApi
              .verifyUsingContent(BLOCKCHAIN_PROOF_CONFIG, proofRequest, "example-id", null, null, null);
            final String determinedChainId = verifyResponse.getPerHashProofChain().getChainId();
            System.out.println(String.format("Determined chain ID using verification: %s", determinedChainId));

            // Let's check whether they do match
            Assert.assertEquals(chainId, determinedChainId);

            // Now register two actions (for 2 users) in the newly created chain.
            // In this example we are creating a simple hash. If you want to make it more resilient we suggest to generate a signature from the hash
            final Entry actionEntry1 = constructEntry(EMAIL1, USER_ID1, ACTION);
            final CommittedEntryResponse commitedEntry1 = easyBlockchainApi
              .createEntry(FACTOM_PUBLIC_CONTEXT, chainId, actionEntry1, OffsetDateTime.now());
            final Entry actionEntry2 = constructEntry(EMAIL2, USER_ID2, ACTION);
            final CommittedEntryResponse commitedEntry2 = easyBlockchainApi
              .createEntry(FACTOM_PUBLIC_CONTEXT, chainId, actionEntry2, OffsetDateTime.now());


        } catch (ApiException ae1) {
            System.err.println(ae1.getResponseBody());
            Assert.fail(ae1.getResponseBody());
        } catch (com.sphereon.sdk.blockchain.easy.handler.ApiException ae2) {
            System.err.println(ae2.getResponseBody());
            Assert.fail(ae2.getResponseBody());
        }
    }

    private String createBlockchainProofConfig() throws ApiException {
        System.out.println("Creating blockchain proof configuration...");
        // Per hash proof chain, using a secret for symmetrical signatures
        final ChainSettings chainSettings = new ChainSettings()
          .addContentRegistrationChainTypesItem(ContentRegistrationChainTypesEnum.PER_HASH_PROOF_CHAIN)
          .hashAlgorithm(HashAlgorithmEnum._256)
          .version(VersionEnum.NUMBER_1)
          .signatureSettings(new SignatureSettings()
            .signatureType(SignatureTypeEnum.SECRET)
            .base64Secret(Base64.getEncoder().encodeToString("my-secret".getBytes()))
          );

        final CreateConfigurationRequest configurationRequest = new CreateConfigurationRequest()
          .context(FACTOM_PUBLIC_CONTEXT)
          .accessMode(AccessModeEnum.PRIVATE)
          .name(BLOCKCHAIN_PROOF_CONFIG)
          .initialSettings(chainSettings);

        final ConfigurationResponse configuration = blockchainProofConfApi.createConfiguration(configurationRequest);
        System.out.println(String
          .format("Created blockchain proof configuration named %s, recieved id %s", configuration.getConfiguration().getName(),
            configuration.getConfiguration().getId()));
        return configuration.getConfiguration().getId();
    }


    /**
     * Create an entry object for an action and a specific e-mail, user id and action
     *
     * @param email
     * @param userId
     * @param action
     * @return
     */
    private Entry constructEntry(final String email, final String userId, final String action) {
        final EntryData firstEntryData = new EntryData()
          .externalIds(Arrays.asList(
            // We use the external ids to denote the company and the version of the action in the content field
            // This sort of acts as a descriptor how to interpret the data in the content field.
            // In the future we could add more actions, or change the version if the structure of the content would change
            new ExternalId().value(APPLICATION_NAME.getBytes()),
            new ExternalId().value(ACTION.getBytes()),
            new ExternalId().value(V_1.getBytes())
          ))
          // We are creating a hash of these values. If you want to make it more resiliant and bind the hash to te app, we suggest to create a signature from the hash
          .content(actionHash(email, userId, action));

        final Entry firstAction = new Entry().entryData(firstEntryData);
        return firstAction;
    }

    /**
     * We create a one way hash from a tuple of input data to prove that an action has taken place.
     * <p>
     * Please note, that a hash could be generated by anyone. Especially if they know your schema and input data. We suggest to use asymmetrical keys
     * or use our crypto-keys API to sign the hash, so that you can filter and prove that your application created/signed the hash.
     *
     * @param emailAddress
     * @param userId
     * @param action
     * @return
     */
    private byte[] actionHash(final String emailAddress, final String userId, final String action) {
        // We create a hash out of the email address, userid and action, in order to ensure there is enough entropy
        final String digest = String.format("%s-%s-%s", emailAddress, userId, action);

        // Generate the SHA-256 on the lowercase digest (making sure we do not get a different hash if someone provides and uppercase e-mail address)
        return Digest.getInstance().getHash(Algorithm.SHA_256, digest.toLowerCase());

        // More elaborate use cases could be to store a timestamp as part of the entry data next to the version and then to include the timestamp and version in the hash calculation
    }

    /**
     * Retrieve the access token and configure the API clients to use this token
     */
    private void configureApis() {
        final String accessToken = getAuthToken().execute().getAccessToken();
        easyBlockchainApi.getApiClient().setAccessToken(accessToken);
        blockchainProofRegApi.getApiClient().setAccessToken(accessToken);
        blockchainProofVerApi.getApiClient().setAccessToken(accessToken);
        blockchainProofConfApi.getApiClient().setAccessToken(accessToken);
    }


    /**
     * Reads the consumer keys and secrets from the environment values AUTHENTICATION_EXAMPLE_CONSUMER_KEY and AUTHENTICATION_EXAMPLE_CONSUMER_SECRET
     * <p>
     * * @see <a href="https://github.com/Sphereon-Opensource/authentication-lib#how-to-use">Authentication Library Github</a> for more info
     * </p>
     *
     * @return The authentication API
     */
    private AuthenticationApi getAuthApi() {
        ApiConfiguration tokenApiConfig = new ApiConfiguration.Builder()
          .withApplication("tests.blockchain-proof")
          .withPersistenceType(PersistenceType.SYSTEM_ENVIRONMENT)
          .withPersistenceMode(PersistenceMode.READ_WRITE)
          .withAutoEncryptSecrets(true)
          .build();
        return new AuthenticationApi.Builder().withConfiguration(tokenApiConfig).build();
    }

    /**
     * Retrieve the auth token from the API gateway
     *
     * @return
     */
    private TokenRequest getAuthToken() {
        return getAuthApi().requestToken()
          .withValidityPeriod(TOKEN_VALIDITY_SECONDS)
          .build();
    }

}
