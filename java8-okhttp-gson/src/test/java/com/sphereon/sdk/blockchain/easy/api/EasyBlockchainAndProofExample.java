package com.sphereon.sdk.blockchain.easy.api;

import com.sphereon.libs.authentication.api.AuthenticationApi;
import com.sphereon.libs.authentication.api.TokenRequest;
import com.sphereon.libs.authentication.api.config.ApiConfiguration;
import com.sphereon.libs.authentication.api.config.PersistenceMode;
import com.sphereon.libs.authentication.api.config.PersistenceType;
import com.sphereon.libs.blockchain.commons.Digest;
import com.sphereon.libs.blockchain.commons.Digest.Algorithm;
import com.sphereon.sdk.blockchain.easy.model.AnchoredEntryResponse;
import com.sphereon.sdk.blockchain.easy.model.CommittedEntryResponse;
import com.sphereon.sdk.blockchain.easy.model.Entry;
import com.sphereon.sdk.blockchain.easy.model.EntryData;
import com.sphereon.sdk.blockchain.easy.model.ExternalId;
import com.sphereon.sdk.blockchain.proof.api.RegistrationApi;
import com.sphereon.sdk.blockchain.proof.api.VerificationApi;
import com.sphereon.sdk.blockchain.proof.handler.ApiException;
import com.sphereon.sdk.blockchain.proof.model.ContentRequest;
import com.sphereon.sdk.blockchain.proof.model.ContentRequest.HashProviderEnum;
import com.sphereon.sdk.blockchain.proof.model.RegisterContentResponse;
import com.sphereon.sdk.blockchain.proof.model.VerifyContentResponse;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.UUID;
import org.junit.Assert;
import org.junit.Test;

/**
 * This example combines usage of the blockchain proof API to register content/files to get a unique chain id per hash
 * Once the chain has been created, the response contains the chain id.
 * We use that chain id and the easy blockchain API to create additional entries with metadata in the chain for that hash.
 * In this example we are creating 2 actions for different users, to denote they have made an approval on the document belonging to this hash.
 *
 * This example is rather simple. Given anybody could put hashes on the blockchain, we suggest to sign the hash using an asymmetrical key,
 * or by using our crypto-keys API. This ensures you can always check that the hash really has been generated by your application
 *
 */
public class EasyBlockchainAndProofExample {

    public static final long TOKEN_VALIDITY_SECONDS = 5400;
    // This context for the Easy Blockchain is available to everyone and uses the Factom Blockchain
    public static final String FACTOM_PUBLIC_CONTEXT = "factom";
    // This Blockchain Proof configuration name needs to be availble. Replace with your config name. We generate one on the fly for this example
    public static final String BLOCKCHAIN_PROOF_CONFIG = "example";

    // The easy blockchain and blockchain proof SDK clients
    private final AllApi easyBlockchainApi = new AllApi();
    private final RegistrationApi blockchainProofRegApi = new RegistrationApi();
    private final VerificationApi blockchainProofVerApi = new VerificationApi();

    // These are our tags/external ids when creating entries on the blockchain
    public static final String APPLICATION_NAME = "EXAMPLE-APP";
    public static final String ACTION = "APPROVE";
    public static final String V_1 = "v1";

    // Example data that we use as input for a hash
    public static final String EMAIL1 = "example1@example.com";
    public static final String EMAIL2 = "example2@example.com";
    public static final String USER_ID1 = UUID.randomUUID().toString();
    public static final String USER_ID2 = UUID.randomUUID().toString();

    /**
     * This example uses blockchain proof to register a new chain, then uses the easy blockchain to register entries
     * <p>
     * For this example a so called chain per hash is being used. Meaning that a different hash results in a different chain for the entries.
     *
     * @throws ApiException
     */
    @Test
    public void example() throws ApiException, com.sphereon.sdk.blockchain.easy.handler.ApiException {
        configureApis();

        // Create a SHA-256 hash from random content using the easy blockchain lib. Could also be file contents
        final byte[] hash = Digest.getInstance().getHash(Algorithm.SHA_256, String.format("Unique Example input: %d", System.currentTimeMillis()));

        // We want to register a new per hash chain with some content. We have chosen to hash the submitted value ourselves
        final ContentRequest proofRequest = new ContentRequest().hashProvider(HashProviderEnum.CLIENT).content(hash);

        // Register the chain using the blockchain proof API
        final RegisterContentResponse registerResponse = blockchainProofRegApi
          .registerUsingContent("config", proofRequest, "example-id", null, null, null);

        // Retrieve the per hash chain id from the response. Typically makes sense to store this in the DB for later usage
        final String chainId = registerResponse.getPerHashProofChain().getChainId();

        // Alternatively we can always determine the chainId even if we have not registered it before or forgot the value. It will also return whether the chain exists
        final VerifyContentResponse verifyResponse = blockchainProofVerApi.verifyUsingContent("config", proofRequest, "example-id", null, null, null);
        final String determinedChainId = verifyResponse.getPerHashProofChain().getChainId();

        // Let's check whether they do match
        Assert.assertEquals(chainId, determinedChainId);

        // Now register two actions (for 2 users) in the newly created chain.
        // In this example we are creating a simple hash. If you want to make it more resilient we suggest to generate a signature from the hash
        final Entry actionEntry1 = constructEntry(EMAIL1, USER_ID1, ACTION);
        final CommittedEntryResponse commitedEntry1 = easyBlockchainApi
          .createEntry(FACTOM_PUBLIC_CONTEXT, chainId, actionEntry1, OffsetDateTime.now());
        final Entry actionEntry2 = constructEntry(EMAIL2, USER_ID2, ACTION);
        final CommittedEntryResponse commitedEntry2 = easyBlockchainApi
          .createEntry(FACTOM_PUBLIC_CONTEXT, chainId, actionEntry2, OffsetDateTime.now());

        // Now lets traverse the chain to read the entries that have been put on the blockchain
        // This is the last registered action entry corresponding to commitedEntry2 above
        final AnchoredEntryResponse anchoredEntryResponse2 = easyBlockchainApi.lastEntry(FACTOM_PUBLIC_CONTEXT, chainId);

        // This is the first registered action entry corresponding to commitedEntry1 above
        final AnchoredEntryResponse anchoredEntryResponse1 = easyBlockchainApi
          .previousEntryById(FACTOM_PUBLIC_CONTEXT, chainId, anchoredEntryResponse2.getAnchoredEntry().getEntryId(),
            anchoredEntryResponse2.getCurrentAnchorTime());

        // This is the actual first entry that created the chain, corresponding to the blockchainProof registerResponse
        final AnchoredEntryResponse anchoredRegisterResponse = easyBlockchainApi
          .previousEntryById(FACTOM_PUBLIC_CONTEXT, chainId, anchoredEntryResponse1.getAnchoredEntry().getEntryId(),
            anchoredEntryResponse1.getCurrentAnchorTime());

        // Let's do some checks on whether the stored hash in the blockchain matches what we would expect them to be
        Assert.assertEquals(actionHash(EMAIL1, USER_ID1, ACTION), anchoredEntryResponse1.getAnchoredEntry().getEntry().getEntryData().getContent());
        Assert.assertEquals(actionHash(EMAIL2, USER_ID2, ACTION), anchoredEntryResponse2.getAnchoredEntry().getEntry().getEntryData().getContent());
        Assert.assertEquals(commitedEntry1.getEntry().getEntry(), anchoredEntryResponse1.getAnchoredEntry().getEntry());
        Assert.assertEquals(commitedEntry2.getEntry().getEntry(), anchoredEntryResponse2.getAnchoredEntry().getEntry());

    }


    /**
     * Create an entry object for an action and a specific e-mail, user id and action
     *
     * @param email
     * @param userId
     * @param action
     * @return
     */
    private Entry constructEntry(final String email, final String userId, final String action) {
        final EntryData firstEntryData = new EntryData()
          .externalIds(Arrays.asList(
            // We use the external ids to denote the company and the version of the action in the content field
            // This sort of acts as a descriptor how to interpret the data in the content field.
            // In the future we could add more actions, or change the version if the structure of the content would change
            new ExternalId().value(APPLICATION_NAME.getBytes()),
            new ExternalId().value(ACTION.getBytes()),
            new ExternalId().value(V_1.getBytes())
          ))
          // We are creating a hash of these values. If you want to make it more resiliant and bind the hash to te app, we suggest to create a signature from the hash
          .content(actionHash(email, userId, action));

        final Entry firstAction = new Entry().entryData(firstEntryData);
        return firstAction;
    }

    /**
     * We create a one way hash from a tuple of input data to prove that an action has taken place.
     *
     * Please note, that a hash could be generated by anyone. Especially if they know your schema and input data.
     * We suggest to use asymmetrical keys or use our crypto-keys API to sign the hash, so that you can filter and prove
     * that your application created/signed the hash.
     *
     * @param emailAddress
     * @param userId
     * @param action
     * @return
     */
    private byte[] actionHash(final String emailAddress, final String userId, final String action) {
        // We create a hash out of the email address, userid and action, in order to ensure there is enough entropy
        final String digest = String.format("%s-%s-%s", emailAddress, userId, action);

        // Generate the SHA-256 on the lowercase digest (making sure we do not get a different hash if someone provides and uppercase e-mail address)
        return Digest.getInstance().getHash(Algorithm.SHA_256, digest.toLowerCase());

        // More elaborate use cases could be to store a timestamp as part of the entry data next to the version and then to include the timestamp and version in the hash calculation
    }

    /**
     * Retrieve the access token and configure the API clients to use this token
     */
    private void configureApis() {
        final String accessToken = getAuthToken().execute().getAccessToken();
        easyBlockchainApi.getApiClient().setAccessToken(accessToken);
        blockchainProofRegApi.getApiClient().setAccessToken(accessToken);
        blockchainProofVerApi.getApiClient().setAccessToken(accessToken);
    }


    /**
     * Reads the consumer keys and secrets from the environment values AUTHENTICATION_EXAMPLE_CONSUMER_KEY and AUTHENTICATION_EXAMPLE_CONSUMER_SECRET
     * <p>
     * * @see <a href="https://github.com/Sphereon-Opensource/authentication-lib#how-to-use">Authentication Library Github</a> for more info
     * </p>
     *
     * @return The authentication API
     */
    private AuthenticationApi getAuthApi() {
        ApiConfiguration tokenApiConfig = new ApiConfiguration.Builder()
          .withApplication("example")
          .withPersistenceType(PersistenceType.SYSTEM_ENVIRONMENT)
          .withPersistenceMode(PersistenceMode.READ_WRITE)
          .withAutoEncryptSecrets(true)
          .build();
        return new AuthenticationApi.Builder().withConfiguration(tokenApiConfig).build();
    }

    /**
     * Retrieve the auth token from the API gateway
     *
     * @return
     */
    private TokenRequest getAuthToken() {
        return getAuthApi().requestToken()
          .withValidityPeriod(TOKEN_VALIDITY_SECONDS)
          .build();
    }

}
